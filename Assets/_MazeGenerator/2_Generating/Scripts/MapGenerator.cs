using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace MazeCreation
{
    public class MatrixPosition
    {
        public int x;
        public int z;

        public MatrixPosition(int _x, int _z)
        {
            x = _x;
            z = _z;
        }
    }

    public class MapGenerator
	{
        internal static int[,] _map;
        internal static int _width;
        internal static int _depth;

        // заменить на Dictionary?
        public static List<MatrixPosition> directions = new List<MatrixPosition> {
											new MatrixPosition(1,0), // вправо
											new MatrixPosition(0,1), // вверх
											new MatrixPosition(-1,0), // влево
											new MatrixPosition(0, -1) //вниз
		                                    };

        public int[,] GenerateMap(int[,] initializedMap)
		{
            _map = initializedMap;
            _width = _map.GetLength(0);
            _depth = _map.GetLength(1);

            UseAlgorithm();
            Debug.Log($"Map[{_width},{_depth}] generated by {this}.");

            return _map;
        }

        internal virtual void UseAlgorithm() { }

        internal static int[] DefinePattern(int x, int z) // пока не работает, да и не нужно до генерации подземелий. нужно попробовать SequenceEquals для сравнения массивов
        {
            int[] pattern = new int[9];
            for (int i = 0; i < 9; i++)
            {
                switch (i)
                {
                    case 0:
                        pattern[i] = _map[x - 1, z + 1];
                        break;
                    case 1:
                        pattern[i] = _map[x, z + 1];
                        break;
                    case 2:
                        pattern[i] = _map[x + 1, z + 1];
                        break;
                    case 3:
                        pattern[i] = _map[x - 1, z];
                        break;
                    case 4:
                        pattern[i] = _map[x, z];
                        break;
                    case 5:
                        pattern[i] = _map[x + 1, z];
                        break;
                    case 6:
                        pattern[i] = _map[x - 1, z - 1];
                        break;
                    case 7:
                        pattern[i] = _map[x, z - 1];
                        break;
                    case 8:
                        pattern[i] = _map[x + 1, z - 1];
                        break;
                }
            }

            //Debug.Log($"Pattern {x},{z}: {pattern[0]},{pattern[1]},{pattern[2]},{pattern[3]},{pattern[4]},{pattern[5]},{pattern[6]},{pattern[7]},{pattern[8]}");
            return pattern;
        }
        internal static bool CheckPattern(int x, int z, int[] pattern)
        {
            int count = 0;
            int pos = 0;
            for (int row = 1; row > -2; row--)
            {
                for (int column = -1; column < 2; column++)
                {
                    if (pattern[pos] == _map[x + column, z + row] || pattern[pos] == 5)
                        count++;
                    pos++;
                }
            }

            return (count == 9);
        }
        internal static int CountSquareEmptyNeighbours(int x, int z)
        {
            int count = 0;
            if (x <= 0 || x >= _width - 1 || z <= 0 || z >= _depth - 1) return 5;
            if (_map[x - 1, z] == 0) count++;
            if (_map[x + 1, z] == 0) count++;
            if (_map[x, z - 1] == 0) count++;
            if (_map[x, z + 1] == 0) count++;
            return count;
        }
        internal static int CountSquareMazeNeighbours(int x, int z)
        {
            int count = 0;
            for (int d = 0; d < directions.Count; d++)
            {
                int nx = x + directions[d].x;
                int nz = z + directions[d].z;
                if (_map[nx, nz] == 2)
                    count++;
            }

            return count;
        }
        internal static int CountDiagonalEmptyNeighbours(int x, int z)
        {
            int count = 0;
            if (x <= 0 || x >= _width - 1 || z <= 0 || z >= _depth - 1) return 5;
            if (_map[x - 1, z - 1] == 0) count++;
            if (_map[x + 1, z + 1] == 0) count++;
            if (_map[x - 1, z + 1] == 0) count++;
            if (_map[x + 1, z - 1] == 0) count++;
            return count;
        }
        internal static int CountAllEmptyNeighbours(int x, int z)
        {
            return CountSquareEmptyNeighbours(x, z) + CountDiagonalEmptyNeighbours(x, z);
        }
    }
}